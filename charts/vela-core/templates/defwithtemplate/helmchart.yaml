# Code generated by KubeVela templates. DO NOT EDIT. Please edit the original cue file.
# Definition source cue file: vela-templates/definitions/internal/helmchart.cue
apiVersion: core.oam.dev/v1beta1
kind: ComponentDefinition
metadata:
  annotations:
    definition.oam.dev/description: Deploy Helm charts natively in KubeVela without FluxCD
  labels:
    custom.definition.oam.dev/category: helm
  name: helmchart
  namespace: {{ include "systemDefinitionNamespace" . }}
spec:
  schematic:
    cue:
      template: "import (\n\t\"vela/helm\"\n)\n\noutput:  _\noutputs: _\n\nparameter: {\n\t// Chart source configuration\n\tchart: {\n\t\t// Chart location - automatically detected based on format:\n\t\t// - OCI: \"oci://ghcr.io/org/charts/app\"\n\t\t// - Direct URL: \"https://example.com/charts/app-1.0.0.tgz\"\n\t\t// - Repo chart: \"postgresql\" (requires repoURL to be set)\n\t\tsource: string\n\n\t\t// Repository URL for repository-based charts\n\t\trepoURL?: string\n\n\t\t// Version/tag for repository and OCI charts (ignored for direct URLs)\n\t\tversion?: string | *\"latest\"\n\n\t\t// Authentication (optional) - TODO: Not yet implemented\n\t\t// auth?: {\n\t\t// \t// Reference to Secret containing credentials\n\t\t// \tsecretRef?: {\n\t\t// \t\tname: string\n\t\t// \t\tnamespace?: string | *context.namespace\n\t\t// \t}\n\t\t// }\n\t}\n\n\t// Release configuration (optional - uses context defaults)\n\trelease?: {\n\t\t// Release name (defaults to component name)\n\t\tname?: string | *context.name\n\t\t// Target namespace (defaults to Application namespace)\n\t\tnamespace?: string | *context.namespace\n\t}\n\n\t// Inline values (highest priority)\n\tvalues?: {...}\n\n\t// Value sources (merged in order) - TODO: Not yet implemented\n\t// valuesFrom?: [...{\n\t// \tkind: \"Secret\" | \"ConfigMap\" | \"OCIRepository\"\n\t// \tname: string\n\t// \tnamespace?: string\n\t// \tkey?: string        // Specific key in ConfigMap/Secret\n\t// \turl?: string        // For OCIRepository\n\t// \ttag?: string        // For OCIRepository\n\t// \toptional?: bool | *false // Don't fail if source doesn't exist\n\t// }]\n\n\t// Health status criteria - defines when the Helm deployment is considered healthy\n\thealthStatus?: [...{\n\t\t// Resource to check\n\t\tresource: {\n\t\t\t// Resource kind (e.g., \"Deployment\", \"StatefulSet\", \"Job\", \"Service\")\n\t\t\tkind: string\n\t\t\t// Optional: specific resource name (if not specified, checks first of kind)\n\t\t\tname?: string\n\t\t}\n\t\t// Health condition to verify\n\t\tcondition: {\n\t\t\t// Condition type to check:\n\t\t\t// - \"Ready\": Resource has Ready=True condition\n\t\t\t// - \"Available\": Resource has Available=True condition  \n\t\t\t// - \"Progressing\": Check if still progressing (use status: \"False\" to wait for completion)\n\t\t\t// - \"ReplicasReady\": All replicas are ready (for Deployment/StatefulSet)\n\t\t\t// - \"PodReady\": Pod is Running or Succeeded (for Job/Pod)\n\t\t\t// - \"JobComplete\": Job has Complete=True condition\n\t\t\ttype: \"Ready\" | \"Available\" | \"Progressing\" | \"ReplicasReady\" | \"PodReady\" | \"JobComplete\"\n\t\t\t// Expected status (default: \"True\", use \"False\" for conditions like Progressing)\n\t\t\tstatus?: \"True\" | \"False\"\n\t\t}\n\t}]\n\n\t// Rendering options\n\toptions?: {\n\t\tincludeCRDs?:     bool | *true    // Install CRDs from chart\n\t\tskipTests?:       bool | *true    // Skip test resources\n\t\tskipHooks?:       bool | *false   // Skip hook resources\n\t\tcreateNamespace?: bool | *true    // Create namespace if it doesn't exist\n\t\ttimeout?:         string | *\"5m\"  // Rendering timeout\n\t\tmaxHistory?:      int | *10       // Revisions to keep\n\t\tatomic?:          bool | *false   // Rollback on failure\n\t\twait?:            bool | *false   // Wait for resources\n\t\twaitTimeout?:     string | *\"10m\" // Wait timeout\n\t\tforce?:           bool | *false   // Force resource updates\n\t\trecreatePods?:    bool | *false   // Recreate pods on upgrade\n\t\tcleanupOnFail?:   bool | *false   // Cleanup on failure\n\n\t\t// Cache configuration\n\t\tcache?: {\n\t\t\t// Cache key prefix (defaults to \"{context.appName}-{context.name}\")\n\t\t\t// Examples: \"shared\", \"dev-cluster\", \"prod-env\"\n\t\t\tkey?: string\n\t\t\t// TTL for this specific chart (overrides automatic detection)\n\t\t\t// Examples: \"24h\", \"5m\", \"30s\", \"0\" (disable cache)\n\t\t\tttl?: string\n\t\t\t// Or specify different TTLs for immutable vs mutable versions\n\t\t\timmutableTTL?: string | *\"24h\" // TTL for semantic versions (1.2.3, v2.0.0)\n\t\t\tmutableTTL?:   string | *\"5m\"  // TTL for mutable tags (latest, dev, main)\n\t\t}\n\n\t\t// Post-rendering - Future enhancement\n\t\t// Planned: CUE-based post-rendering for resource transformation\n\t\t// Would allow users to write CUE templates to modify rendered resources\n\t\t// with full access to KubeVela context (appName, namespace, etc.)\n\t\t// Requires CUE-in-CUE runtime execution capability\n\t\t// postRender?: {\n\t\t// \ttemplate: string  // CUE template for transforming resources\n\t\t// }\n\t}\n}\n\n// Set default release configuration\n_release: {\n\tif parameter.release != _|_ {\n\t\tparameter.release\n\t}\n\tif parameter.release == _|_ {\n\t\tname:      context.name\n\t\tnamespace: context.namespace\n\t}\n}\n\n// Set default options with cache key\n_options: {\n\tif parameter.options != _|_ {\n\t\tparameter.options\n\t}\n\tif parameter.options == _|_ {\n\t\tcache: key: \"\\(context.appName)-\\(context.name)\"\n\t}\n\tif parameter.options != _|_ && parameter.options.cache != _|_ && parameter.options.cache.key == _|_ {\n\t\tcache: {\n\t\t\tparameter.options.cache\n\t\t\tkey: \"\\(context.appName)-\\(context.name)\"\n\t\t}\n\t}\n}\n\n// Render the Helm chart using the provider\n_rendered: helm.#Render & {\n\t$params: {\n\t\tchart:   parameter.chart\n\t\trelease: _release\n\t\tif parameter.values != _|_ {\n\t\t\tvalues: parameter.values\n\t\t}\n\n\t\t// TODO: valuesFrom not yet implemented\n\t\t// if parameter.valuesFrom != _|_ {\n\t\t// \tvaluesFrom: parameter.valuesFrom\n\t\t// }\n\t\toptions: _options\n\t}\n}\n\n// Set outputs from rendered resources\nif _rendered.$returns.resources != _|_ {\n\tif len(_rendered.$returns.resources) > 0 {\n\t\t// Take first resource as primary output\n\t\toutput: _rendered.$returns.resources[0]\n\t}\n\n\t// Put remaining resources in outputs\n\tif len(_rendered.$returns.resources) > 1 {\n\t\toutputs: {\n\t\t\tfor i, res in _rendered.$returns.resources if i > 0 {\n\t\t\t\t\"helm-resource-\\(i)\": res\n\t\t\t}\n\t\t}\n\t}\n}\n"
  status:
    customStatus: |-
      if context.status.healthy {
      	message: "Deployed"
      }
      if !context.status.healthy {
      	message: "Deploying"
      }
    healthPolicy: "_healthCheck: {\n\t_criteria: [] | *parameter.healthStatus\n\tif len(_criteria) > 0 {\n\t\t_criteriaResults: [ for criterion in _criteria {\n\t\t\t_targetKind: criterion.resource.kind\n\t\t\t_targetName: criterion.resource.name\n\t\t\t_conditionType: criterion.condition.type\n\t\t\t_conditionStatus: *\"True\" | criterion.condition.status\n\t\t\t// Search through all outputs for matching resource\n\t\t\t_matchingResources: [ for outputKey, resource in context.outputs \n\t\t\t\tif resource.kind == _targetKind && \n\t\t\t\t\t(_targetName == _|_ || resource.metadata.name == _targetName) { \n\t\t\t\t\tresource \n\t\t\t\t} \n\t\t\t]\n\t\t\tif len(_matchingResources) > 0 {\n\t\t\t\t_resource: _matchingResources[0]\n\t\t\t\tif _resource.status.conditions != _|_ {\n\t\t\t\t\t// Look for matching condition\n\t\t\t\t\t_matchingConditions: [ for cond in _resource.status.conditions \n\t\t\t\t\t\tif cond.type == _conditionType && cond.status == _conditionStatus { \n\t\t\t\t\t\t\tcond \n\t\t\t\t\t\t} \n\t\t\t\t\t]\n\t\t\t\t\tresult: len(_matchingConditions) > 0\n\t\t\t\t}\n\t\t\t\tif _resource.status.conditions == _|_ {\n\t\t\t\t\tresult: false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(_matchingResources) == 0 {\n\t\t\t\tresult: false\n\t\t\t}\n\t\t} ]\n\t\t_failedCriteria: [ for r in _criteriaResults if r.result == false { r } ]\n\t\tresult: len(_failedCriteria) == 0\n\t}\n\tif parameter.healthStatus == _|_ {\n\t\tresult: true\n\t}\n}\nisHealth: _healthCheck.result"
  workload:
    type: autodetects.core.oam.dev

