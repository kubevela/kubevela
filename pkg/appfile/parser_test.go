/*
Copyright 2021 The KubeVela Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package appfile

import (
	"context"
	"fmt"
	"reflect"
	"strings"
	"testing"

	"github.com/crossplane/crossplane-runtime/pkg/test"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"github.com/stretchr/testify/assert"
	errors2 "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
	"sigs.k8s.io/yaml"

	workflowv1alpha1 "github.com/kubevela/workflow/api/v1alpha1"

	"github.com/oam-dev/kubevela/apis/core.oam.dev/common"
	"github.com/oam-dev/kubevela/apis/types"

	"github.com/oam-dev/kubevela/apis/core.oam.dev/v1beta1"
	"github.com/oam-dev/kubevela/pkg/oam/util"
	common2 "github.com/oam-dev/kubevela/pkg/utils/common"
)

var expectedExceptApp = &Appfile{
	Name: "application-sample",
	ParsedComponents: []*Component{
		{
			Name: "myweb",
			Type: "worker",
			Params: map[string]interface{}{
				"image": "busybox",
				"cmd":   []interface{}{"sleep", "1000"},
			},
			FullTemplate: &Template{
				TemplateStr: `
      output: {
        apiVersion: "apps/v1"
      	kind:       "Deployment"
      	spec: {
      		selector: matchLabels: {
      			"app.oam.dev/component": context.name
      		}
      
      		template: {
      			metadata: labels: {
      				"app.oam.dev/component": context.name
      			}
      
      			spec: {
      				containers: [{
      					name:  context.name
      					image: parameter.image
      
      					if parameter["cmd"] != _|_ {
      						command: parameter.cmd
      					}
      				}]
      			}
      		}
      
      		selector:
      			matchLabels:
      				"app.oam.dev/component": context.name
      	}
      }
      
      parameter: {
      	// +usage=Which image would you like to use for your service
      	// +short=i
      	image: string
      
      	cmd?: [...string]
      }`,
			},
		},
	},
	WorkflowSteps: []workflowv1alpha1.WorkflowStep{
		{
			WorkflowStepBase: workflowv1alpha1.WorkflowStepBase{
				Name: "suspend",
				Type: "suspend",
			},
		},
	},
}

const componentDefinition = `
apiVersion: core.oam.dev/v1beta1
kind: ComponentDefinition
metadata:
  name: worker
  annotations:
    definition.oam.dev/description: "Long-running scalable backend worker without network endpoint"
spec:
  workload:
    definition:
      apiVersion: apps/v1
      kind: Deployment
  extension:
    template: |
      output: {
      	apiVersion: "apps/v1"
      	kind:       "Deployment"
      	spec: {
      		selector: matchLabels: {
      			"app.oam.dev/component": context.name
      		}

      		template: {
      			metadata: labels: {
      				"app.oam.dev/component": context.name
      			}

      			spec: {
      				containers: [{
      					name:  context.name
      					image: parameter.image

      					if parameter["cmd"] != _|_ {
      						command: parameter.cmd
      					}
      				}]
      			}
      		}

      		selector:
      			matchLabels:
      				"app.oam.dev/component": context.name
      	}
      }

      parameter: {
      	// +usage=Which image would you like to use for your service
      	// +short=i
      	image: string

      	cmd?: [...string]
      }`

const policyDefinition = `
# Code generated by KubeVela templates. DO NOT EDIT. Please edit the original cue file.
# Definition source cue file: vela-templates/definitions/internal/topology.cue
apiVersion: core.oam.dev/v1beta1
kind: PolicyDefinition
metadata:
  annotations:
    definition.oam.dev/description: Determining the destination where components should be deployed to.
  name: topology
  namespace: {{ include "systemDefinitionNamespace" . }}
spec:
  schematic:
    cue:
      template: |
        parameter: {
        	// +usage=Specify the names of the clusters to select.
        	cluster?: [...string]
        	// +usage=Specify the label selector for clusters
        	clusterLabelSelector?: [string]: string
        	// +usage=Deprecated: Use clusterLabelSelector instead.
        	clusterSelector?: [string]: string
        	// +usage=Specify the target namespace to deploy in the selected clusters, default inherit the original namespace.
        	namespace?: string
        }
`

const appfileYaml = `
apiVersion: core.oam.dev/v1beta1
kind: Application
metadata:
  name: application-sample
  namespace: default
spec:
  components:
    - name: myweb
      type: worker
      properties:
        image: "busybox"
        cmd:
        - sleep
        - "1000"
  workflow:
    steps:
    - name: "suspend"
      type: "suspend" 
`

const appfileYaml2 = `
apiVersion: core.oam.dev/v1beta1
kind: Application
metadata:
  name: application-sample
  namespace: default
spec:
  components:
    - name: myweb
      type: worker-notexist
      properties:
        image: "busybox"
`

const appfileYamlEmptyPolicy = `
apiVersion: core.oam.dev/v1beta1
kind: Application
metadata:
  name: application-sample
  namespace: default
spec:
  components: []
  policies:
    - type: garbage-collect
      name: somename
      properties:
`

var _ = Describe("Test application parser", func() {
	It("Test parse an application", func() {
		o := v1beta1.Application{}
		err := yaml.Unmarshal([]byte(appfileYaml), &o)
		Expect(err).ShouldNot(HaveOccurred())

		// Create a mock client
		tclient := test.MockClient{
			MockGet: func(ctx context.Context, key client.ObjectKey, obj client.Object) error {
				if strings.Contains(key.Name, "notexist") {
					return &errors2.StatusError{ErrStatus: metav1.Status{Reason: "NotFound", Message: "not found"}}
				}
				switch o := obj.(type) {
				case *v1beta1.ComponentDefinition:
					wd, err := util.UnMarshalStringToComponentDefinition(componentDefinition)
					if err != nil {
						return err
					}
					*o = *wd
				case *v1beta1.PolicyDefinition:
					ppd, err := util.UnMarshalStringToPolicyDefinition(policyDefinition)
					if err != nil {
						return err
					}
					*o = *ppd
				}
				return nil
			},
		}

		appfile, err := NewApplicationParser(&tclient, pd).GenerateAppFile(context.TODO(), &o)
		Expect(err).ShouldNot(HaveOccurred())
		Expect(equal(expectedExceptApp, appfile)).Should(BeTrue())

		notfound := v1beta1.Application{}
		err = yaml.Unmarshal([]byte(appfileYaml2), &notfound)
		Expect(err).ShouldNot(HaveOccurred())
		_, err = NewApplicationParser(&tclient, pd).GenerateAppFile(context.TODO(), &notfound)
		Expect(err).Should(HaveOccurred())

		By("app with empty policy")
		emptyPolicy := v1beta1.Application{}
		err = yaml.Unmarshal([]byte(appfileYamlEmptyPolicy), &emptyPolicy)
		Expect(err).ShouldNot(HaveOccurred())
		_, err = NewApplicationParser(&tclient, pd).GenerateAppFile(context.TODO(), &emptyPolicy)
		Expect(err).Should(HaveOccurred())
		Expect(err.Error()).Should(ContainSubstring("have empty properties"))
	})
})

func equal(af, dest *Appfile) bool {
	if af.Name != dest.Name || len(af.ParsedComponents) != len(dest.ParsedComponents) {
		return false
	}
	for i, wd := range af.ParsedComponents {
		destWd := dest.ParsedComponents[i]
		if wd.Name != destWd.Name || len(wd.Traits) != len(destWd.Traits) {
			return false
		}
		if !reflect.DeepEqual(wd.Params, destWd.Params) {
			fmt.Printf("%#v | %#v\n", wd.Params, destWd.Params)
			return false
		}
		for j, td := range wd.Traits {
			destTd := destWd.Traits[j]
			if td.Name != destTd.Name {
				fmt.Printf("td:%s dest%s", td.Name, destTd.Name)
				return false
			}
			if !reflect.DeepEqual(td.Params, destTd.Params) {
				fmt.Printf("%#v | %#v\n", td.Params, destTd.Params)
				return false
			}
		}
	}
	return true
}

var _ = Describe("Test application parser", func() {
	var app v1beta1.Application
	var apprev v1beta1.ApplicationRevision
	var wsd v1beta1.WorkflowStepDefinition
	var expectedExceptAppfile *Appfile
	var mockClient test.MockClient

	BeforeEach(func() {
		// prepare WorkflowStepDefinition
		Expect(common2.ReadYamlToObject("testdata/backport-1-2/wsd.yaml", &wsd)).Should(BeNil())

		// prepare verify data
		expectedExceptAppfile = &Appfile{
			Name: "backport-1-2-test-demo",
			ParsedComponents: []*Component{
				{
					Name: "backport-1-2-test-demo",
					Type: "webservice",
					Params: map[string]interface{}{
						"image": "nginx",
					},
					FullTemplate: &Template{
						TemplateStr: `
      output: {
        apiVersion: "apps/v1"
      	kind:       "Deployment"
      	spec: {
      		selector: matchLabels: {
      			"app.oam.dev/component": context.name
      		}
      
      		template: {
      			metadata: labels: {
      				"app.oam.dev/component": context.name
      			}
      
      			spec: {
      				containers: [{
      					name:  context.name
      					image: parameter.image
      
      					if parameter["cmd"] != _|_ {
      						command: parameter.cmd
      					}
      				}]
      			}
      		}
      
      		selector:
      			matchLabels:
      				"app.oam.dev/component": context.name
      	}
      }
      
      parameter: {
      	// +usage=Which image would you like to use for your service
      	// +short=i
      	image: string
      
      	cmd?: [...string]
      }`,
					},
					Traits: []*Trait{
						{
							Name: "scaler",
							Params: map[string]interface{}{
								"replicas": float64(1),
							},
							Template: `
parameter: {
	// +usage=Specify the number of workload
	replicas: *1 | int
}
// +patchStrategy=retainKeys
patch: spec: replicas: parameter.replicas

`,
						},
					},
				},
			},
			WorkflowSteps: []workflowv1alpha1.WorkflowStep{
				{
					WorkflowStepBase: workflowv1alpha1.WorkflowStepBase{
						Name: "apply",
						Type: "apply-application",
					},
				},
			},
		}

		// Create mock client
		mockClient = test.MockClient{
			MockGet: func(ctx context.Context, key client.ObjectKey, obj client.Object) error {
				if strings.Contains(key.Name, "unknown") {
					return &errors2.StatusError{ErrStatus: metav1.Status{Reason: "NotFound", Message: "not found"}}
				}
				switch o := obj.(type) {
				case *v1beta1.ComponentDefinition:
					wd, err := util.UnMarshalStringToComponentDefinition(componentDefinition)
					if err != nil {
						return err
					}
					*o = *wd
				case *v1beta1.WorkflowStepDefinition:
					*o = wsd
				case *v1beta1.ApplicationRevision:
					*o = apprev
				default:
					// skip
				}
				return nil
			},
		}
	})

	When("with apply-application workflowStep", func() {
		BeforeEach(func() {
			// prepare application
			Expect(common2.ReadYamlToObject("testdata/backport-1-2/app.yaml", &app)).Should(BeNil())
			// prepare application revision
			Expect(common2.ReadYamlToObject("testdata/backport-1-2/apprev1.yaml", &apprev)).Should(BeNil())
		})

		It("Test we can parse an application revision to an appFile 1", func() {

			appfile, err := NewApplicationParser(&mockClient, pd).GenerateAppFile(context.TODO(), &app)
			Expect(err).ShouldNot(HaveOccurred())
			Expect(equal(expectedExceptAppfile, appfile)).Should(BeTrue())
			Expect(len(appfile.WorkflowSteps) > 0 &&
				len(appfile.RelatedWorkflowStepDefinitions) == len(appfile.AppRevision.Spec.WorkflowStepDefinitions)).Should(BeTrue())

			Expect(len(appfile.WorkflowSteps) > 0 && func() bool {
				this := appfile.RelatedWorkflowStepDefinitions
				that := appfile.AppRevision.Spec.WorkflowStepDefinitions
				for i, w := range this {
					thatW := that[i]
					if !reflect.DeepEqual(w, thatW) {
						return false
					}
				}
				return true
			}()).Should(BeTrue())
		})
	})

	When("with apply-application and apply-component build-in workflowStep", func() {
		BeforeEach(func() {
			// prepare application
			Expect(common2.ReadYamlToObject("testdata/backport-1-2/app.yaml", &app)).Should(BeNil())
			// prepare application revision
			Expect(common2.ReadYamlToObject("testdata/backport-1-2/apprev2.yaml", &apprev)).Should(BeNil())
		})

		It("Test we can parse an application revision to an appFile 2", func() {

			appfile, err := NewApplicationParser(&mockClient, pd).GenerateAppFile(context.TODO(), &app)
			Expect(err).ShouldNot(HaveOccurred())
			Expect(equal(expectedExceptAppfile, appfile)).Should(BeTrue())
			Expect(len(appfile.WorkflowSteps) > 0 &&
				len(appfile.RelatedWorkflowStepDefinitions) == len(appfile.AppRevision.Spec.WorkflowStepDefinitions)).Should(BeTrue())

			Expect(len(appfile.WorkflowSteps) > 0 && func() bool {
				this := appfile.RelatedWorkflowStepDefinitions
				that := appfile.AppRevision.Spec.WorkflowStepDefinitions
				for i, w := range this {
					thatW := that[i]
					if !reflect.DeepEqual(w, thatW) {
						fmt.Printf("appfile wsd:%s apprev wsd%s", (*w).Name, thatW.Name)
						return false
					}
				}
				return true
			}()).Should(BeTrue())
		})
	})

	When("with unknown workflowStep", func() {
		BeforeEach(func() {
			// prepare application
			Expect(common2.ReadYamlToObject("testdata/backport-1-2/app.yaml", &app)).Should(BeNil())
			// prepare application revision
			Expect(common2.ReadYamlToObject("testdata/backport-1-2/apprev3.yaml", &apprev)).Should(BeNil())
		})

		It("Test we can parse an application revision to an appFile 3", func() {

			_, err := NewApplicationParser(&mockClient, pd).GenerateAppFile(context.TODO(), &app)
			Expect(err).Should(HaveOccurred())
			Expect(err.Error()).Should(SatisfyAll(
				ContainSubstring("failed to get workflow step definition apply-application-unknown: not found"),
				ContainSubstring("failed to parseWorkflowStepsForLegacyRevision")),
			)
		})
	})
})

func TestParser_parseTraits(t *testing.T) {
	type args struct {
		workload *Component
		comp     common.ApplicationComponent
	}
	tests := []struct {
		name                 string
		args                 args
		wantErr              assert.ErrorAssertionFunc
		mockTemplateLoaderFn TemplateLoaderFn
		validateFunc         func(w *Component) bool
	}{
		{
			name: "test empty traits",
			args: args{
				comp: common.ApplicationComponent{},
			},
			wantErr: assert.NoError,
		},
		{
			name: "test parse trait properties error",
			args: args{
				comp: common.ApplicationComponent{
					Traits: []common.ApplicationTrait{
						{
							Type: "expose",
							Properties: &runtime.RawExtension{
								Raw: []byte("invalid properties"),
							},
						},
					},
				},
			},
			wantErr: assert.Error,
		},
		{
			name: "test parse trait error",
			args: args{
				comp: common.ApplicationComponent{
					Traits: []common.ApplicationTrait{
						{
							Type: "expose",
							Properties: &runtime.RawExtension{
								Raw: []byte(`{"unsupported": "{\"key\":\"value\"}"}`),
							},
						},
					},
				},
			},
			mockTemplateLoaderFn: func(context.Context, client.Client, string, types.CapType) (*Template, error) {
				return nil, fmt.Errorf("unsupported key not found")
			},
			wantErr: assert.Error,
		},
		{
			name: "test parse trait success",
			args: args{
				comp: common.ApplicationComponent{
					Traits: []common.ApplicationTrait{
						{
							Type: "expose",
							Properties: &runtime.RawExtension{
								Raw: []byte(`{"annotation": "{\"key\":\"value\"}"}`),
							},
						},
					},
				},
				workload: &Component{},
			},
			wantErr: assert.NoError,
			mockTemplateLoaderFn: func(ctx context.Context, reader client.Client, s string, capType types.CapType) (*Template, error) {
				return &Template{
					TemplateStr:        "template",
					CapabilityCategory: "network",
					Health:             "true",
					CustomStatus:       "healthy",
				}, nil
			},
			validateFunc: func(w *Component) bool {
				return w != nil && len(w.Traits) != 0 && w.Traits[0].Name == "expose" && w.Traits[0].Template == "template"
			},
		},
	}

	p := NewApplicationParser(nil, pd)
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p.tmplLoader = tt.mockTemplateLoaderFn
			err := p.parseTraits(context.Background(), tt.args.workload, tt.args.comp)
			tt.wantErr(t, err, fmt.Sprintf("parseTraits(%v, %v)", tt.args.workload, tt.args.comp))
			if tt.validateFunc != nil {
				assert.True(t, tt.validateFunc(tt.args.workload))
			}
		})
	}
}

func TestParser_parseTraitsFromRevision(t *testing.T) {
	type args struct {
		comp     common.ApplicationComponent
		appRev   *v1beta1.ApplicationRevision
		workload *Component
	}
	tests := []struct {
		name         string
		args         args
		validateFunc func(w *Component) bool
		wantErr      assert.ErrorAssertionFunc
	}{
		{
			name: "test empty traits",
			args: args{
				comp: common.ApplicationComponent{},
			},
			wantErr: assert.NoError,
		},
		{
			name: "test parse traits properties error",
			args: args{
				comp: common.ApplicationComponent{
					Traits: []common.ApplicationTrait{
						{
							Type:       "expose",
							Properties: &runtime.RawExtension{Raw: []byte("invalid")},
						},
					},
				},
				workload: &Component{},
			},
			wantErr: assert.Error,
		},
		{
			name: "test parse traits from revision failed",
			args: args{
				comp: common.ApplicationComponent{
					Traits: []common.ApplicationTrait{
						{
							Type:       "expose",
							Properties: &runtime.RawExtension{Raw: []byte(`{"appRevisionName": "appRevName"}`)},
						},
					},
				},
				appRev: &v1beta1.ApplicationRevision{
					Spec: v1beta1.ApplicationRevisionSpec{
						ApplicationRevisionCompressibleFields: v1beta1.ApplicationRevisionCompressibleFields{
							TraitDefinitions: map[string]*v1beta1.TraitDefinition{},
						},
					},
				},
				workload: &Component{},
			},
			wantErr: assert.Error,
		},
		{
			name: "test parse traits from revision success",
			args: args{
				comp: common.ApplicationComponent{
					Traits: []common.ApplicationTrait{
						{
							Type:       "expose",
							Properties: &runtime.RawExtension{Raw: []byte(`{"appRevisionName": "appRevName"}`)},
						},
					},
				},
				appRev: &v1beta1.ApplicationRevision{
					Spec: v1beta1.ApplicationRevisionSpec{
						ApplicationRevisionCompressibleFields: v1beta1.ApplicationRevisionCompressibleFields{
							TraitDefinitions: map[string]*v1beta1.TraitDefinition{
								"expose": {
									Spec: v1beta1.TraitDefinitionSpec{
										RevisionEnabled:    true,
										AppliesToWorkloads: []string{"*"},
									},
								},
							},
						},
					},
				},
				workload: &Component{},
			},
			wantErr: assert.NoError,
			validateFunc: func(w *Component) bool {
				return w != nil && len(w.Traits) == 1 && w.Traits[0].Name == "expose"
			},
		},
	}
	p := NewApplicationParser(fake.NewClientBuilder().Build(), pd)
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.wantErr(t, p.parseTraitsFromRevision(tt.args.comp, tt.args.appRev, tt.args.workload), fmt.Sprintf("parseTraitsFromRevision(%v, %v, %v)", tt.args.comp, tt.args.appRev, tt.args.workload))
			if tt.validateFunc != nil {
				assert.True(t, tt.validateFunc(tt.args.workload))
			}
		})
	}
}
